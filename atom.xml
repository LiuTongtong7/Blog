<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neverland</title>
  
  <subtitle>Write the code. Change the world.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://neverland.siyuan12.com/"/>
  <updated>2015-03-31T06:26:30.000Z</updated>
  <id>http://neverland.siyuan12.com/</id>
  
  <author>
    <name>Liu Tongtong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac各种折腾v1.0</title>
    <link href="http://neverland.siyuan12.com/2015/03/31/Mac%E5%90%84%E7%A7%8D%E6%8A%98%E8%85%BEv1-0/"/>
    <id>http://neverland.siyuan12.com/2015/03/31/Mac各种折腾v1-0/</id>
    <published>2015-03-31T02:03:33.000Z</published>
    <updated>2015-03-31T06:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="硬件-amp-软件环境"><a href="#硬件-amp-软件环境" class="headerlink" title="硬件 &amp; 软件环境"></a>硬件 &amp; 软件环境</h2><ul><li>Macbook pro 13-inch, Mid 2012</li><li>OS X 10.10.2</li></ul><h2 id="合并磁盘失败"><a href="#合并磁盘失败" class="headerlink" title="合并磁盘失败"></a>合并磁盘失败</h2><p>合并磁盘失败通常发生在抹去BootCamp上的windows时。不知道大家有没有尝试过抹去windows，虽然BootCamp提供了抹去windows的功能，但是本人抹过几次，从来没有成功把回收的windows硬盘空间合并进Mac硬盘空间。即使windows所占硬盘空间不大，但逼死强迫症OTZ。</p><p>解决办法：重启电脑，按command+s进入命令行启动页面，输入<code>fsck -f</code>，再输入<code>reboot</code>，系统会重启。启动完毕后再利用BootCamp或Disk Utility合并即可。</p><h2 id="关闭Dashboard"><a href="#关闭Dashboard" class="headerlink" title="关闭Dashboard"></a>关闭Dashboard</h2><p>Dashboard真的是挺鸡肋的功能，尤其在Yosemite的通知中心极大强化之后。Dashboard的Widgets也停止更新了。在Terminal中输入如下命令即可关闭Dashboard。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; defaults write com.apple.dashboard mcx-disabled -boolean YES</span><br><span class="line">&gt;&gt; killall Dock</span><br></pre></td></tr></table></figure><h2 id="制作OS-X系统安装盘"><a href="#制作OS-X系统安装盘" class="headerlink" title="制作OS X系统安装盘"></a>制作OS X系统安装盘</h2><ol><li>下载安装文件<code>Install OS X Yosemite.app</code>(位置自选，我放在桌面上)</li><li>将U盘(&gt;=8G)格式化为Mac OS扩展（日志式），选项中选择GUID分区表(名称自拟，我设为DISK)</li><li>输入如下命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; sudo ~/Desktop/Install\ OS\ X\ Yosemite.app/Contents/Resources/createinstallmedia --volume /Volumes/DISK --applicationpath ~/Desktop/Install\ OS\ X\ Yosemite.app --nointeraction</span><br></pre></td></tr></table></figure><h2 id="自制Fusion-Drive"><a href="#自制Fusion-Drive" class="headerlink" title="自制Fusion Drive"></a>自制Fusion Drive</h2><p>光驱是MBP101上留之无用，弃之可惜的功能。将光驱功能最大化的办法，就是将光驱改成外接形式，在原来光驱位上加装固态硬盘。然后问题来了，系统怎么搞？常见的办法是将系统安装在固态硬盘上，而把机械硬盘用作数据盘。但是本人系统盘原本就近300G，远超固态硬盘容量。只想用Time Machine拷贝，懒得删文件，所以捣鼓了Fusion Drive，完美解决。过程如下：</p><ol><li>用Time Machine做好系统备份</li><li>用U盘做好系统安装盘</li><li>插上U盘安装盘，按住option开机，进入U盘</li><li>选择磁盘工具，将SSD和HDD都抹为MAC OS扩展（日志式）</li><li>打开终端，输入：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; diskutil list </span><br><span class="line">&gt;&gt; diskutil cs create &quot;Macintosh FD&quot; disk0 disk1(出现Finished CoreStorage operation表示成功)</span><br><span class="line">&gt;&gt; diskutil cs createvolume [LVG的UUID，在上一步的输出中可以看到] jhfs+(j指journal日志式 HFS+是苹果的文件系统，就和前文格式化的Mac OS 扩展日志式一样) &quot;Macintosh FD&quot;(这个名称可以自己起，和前面一样，中间有空格的话两边加双引号) 600g(分区大小)</span><br></pre></td></tr></table></figure><p>制作完成。然后退出终端，从Time Machine恢复或者重新安装即可。</p><p>参考资料：<a href="http://tieba.baidu.com/p/1992600787?pn=1&amp;see_lz=1" target="_blank" rel="noopener"></a></p><h2 id="MAC-VPN"><a href="#MAC-VPN" class="headerlink" title="MAC VPN"></a>MAC VPN</h2><p>Apple死忠，一直坚持用原生App，包括Safari。但是因为插件支持不如Chrome，在使用VPN时没有办法利用插件实现智能代理。而打开全局代理，很多App就没法使用。最好是能在全局使用VPN时也能实现代理。解决办法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPN-&gt;Advanced-&gt;Proxies-&gt;Automatic Proxy Configuration, Proxy Configuration File URL: http://pac.uku.im/pac.pac</span><br></pre></td></tr></table></figure><p>设置完毕后打开VPN，输入URL<code>http://uku.im/check</code>，如果显示true说明设置成功。</p><p>参考资料：<a href="https://github.com/zhuzhuor/Unblock-Youku/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener"></a></p><h2 id="MAC上将Safari书签同步到Chrome"><a href="#MAC上将Safari书签同步到Chrome" class="headerlink" title="MAC上将Safari书签同步到Chrome"></a>MAC上将Safari书签同步到Chrome</h2><p>折腾这件事的原因同上。调试前端不得不用Chrome，于是有了这样的需求。自己折腾的办法如下：</p><ol><li>清空Chrome书签</li><li>书签-&gt;导入书签和设置</li></ol><p>在Windows上直接在Chrome上安装iCloud Bookmarks插件即可。</p>]]></content>
    
    <summary type="html">
    
      爱折腾，根本停不下来。记录了各种搜索得到&amp;搜索不到的问题&amp;方法。
    
    </summary>
    
      <category term="Mac" scheme="http://neverland.siyuan12.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://neverland.siyuan12.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Enigma破解分析</title>
    <link href="http://neverland.siyuan12.com/2015/03/09/Enigma%E7%A0%B4%E8%A7%A3%E5%88%86%E6%9E%90/"/>
    <id>http://neverland.siyuan12.com/2015/03/09/Enigma破解分析/</id>
    <published>2015-03-08T19:21:45.000Z</published>
    <updated>2015-03-09T02:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Enigma的破译可以分成两个阶段。第一个阶段是由波兰人雷杰夫斯基为首完成的，利用的是临时密钥的重复发送。在德国人去除了这一漏洞之后，第二个阶段是由英国人图灵完成的。下面分别介绍。</p><p><img src="/BlogImages/Enigma破解分析/Enigma.png" alt=""></p><h2 id="雷杰夫斯基的工作"><a href="#雷杰夫斯基的工作" class="headerlink" title="雷杰夫斯基的工作"></a>雷杰夫斯基的工作</h2><p>雷杰夫斯基所利用的是德军在使用Enigma机器时重复发送密钥所带来的一个漏洞。德军当时使用Enigma机器的方式为，首先有一个记录了一个月中每天所使用的密钥的密码本，然后在当天的每次加密前，选取三个字母表示转子的初始方向，例如ZRW，作为本次加密的临时密钥，用密码本上当天的密钥加密两遍临时密钥，例如ZRWZRW（为了防止偶然的发送或接受错误），之后在用临时密钥加密正文。所以每天德军所发送的密文的前六个字母都是用当天的密钥所加密的重复两遍的临时密钥。利用这一点，雷杰夫斯基的方法得以奏效。</p><p>假设临时密钥为ZRW，ZRWZRW用当日密钥加密后为ASDFGH。考虑前后两个Z，它们分别被加密为了A和F，这是由于快转子在两次加密Z之间转动了三次。这样A和F之间作为同一个字母第一次和第四次被加密的结果，就存在对应关系。通过当天收集大量的密文，我们可以找出密文第一个和第四个字母间存在的所有的对应关系。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个字母:ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">第四个字母:FQHPLWOGBMVRXUYCZITNJEASDK</span><br></pre></td></tr></table></figure><p>在这个表中，存在若干字母循环圈，例如A-&gt;F-&gt;W-&gt;A。写出所有的字母循环圈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A→F→W→A                3个字母的循环圈B→Q→Z→K→V→E→L→R→I→B    9个字母的循环圈C→H→G→O→Y→D→P→C        7个字母的循环圈J→M→X→S→T→N→U→J        7个字母的循环圈</span><br></pre></td></tr></table></figure><p>这些循环圈是由当日密钥决定的，但是循环圈的个数、每个循环圈的长度只由转子的情况决定，与连接板的情况无关。下面我们通过论证连接线对对应关系的影响来不严格地证明无关性。</p><p>首先我们不妨假设R和W是相连的。现在考虑去除连接线会造成什么影响。把连接线的影响可以分为两部分：输入和输出。从输入的角度来看，如果连接线对输入的影响不存在了（即输入R的时候不会经过连接线到W，但是输出R的时候会经过连接线到W），可以发现对应关系表是不变的（改变的是每列对应的明文字母）。从输出的角度来看，原本输出R时实际输出的是W，原本输出W时实际输出的是R。需要把第一行中R和W在第二行中对应的字母对调，把第二行中R和W在第一行中对应的字母对调。这对循环圈造成的影响是，交换了R和W在循环圈中的位置。循环圈的个数、每个循环圈的长度不变。同样，我们可以证明加上连接线的效果相同。</p><p>所以，循环圈的个数、每个循环圈的长度可以作为转子状态的一个特征。同样，第2、5个字母和第3、6个字母之间的对应关系同样可以找出来，再确定循环圈的个数、每个循环圈的长度，也可以作为转子状态的特征。如果能够构造一个完备的对照表，我们可以通过这些特征，确定转子的状态。由于这里的分析与连接板状态无关，而转子的状态一共有3!*26^3=105456种，可以采用穷举的关系建立上述的对照表。对照表中的一条记录可以是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一和第四字母对应表中有4个循环圈，长度分别为3,9,7,7;</span><br><span class="line">第二和第五字母对应表中有4个循环圈，长度分别为2,3,9,12;</span><br><span class="line">第三和第六字母对应表中有5个循环圈，长度分别为5,5,5,3,8;</span><br></pre></td></tr></table></figure><p>在找出当日密钥中转子的状态之后，还需要确定连接板的情况才能破解密钥。这一部分没有查找相关的资料。在我看来，一种可行的办法是通过增减连接线来交换字母在循环圈中的位置，使得循环圈与实际的循环圈一致。</p><p>雷杰夫斯基的方法的缺陷在于，如果德军不再重复发送密钥，或者增加转子的个数，他的方法便不再可行。</p><h2 id="图灵的工作"><a href="#图灵的工作" class="headerlink" title="图灵的工作"></a>图灵的工作</h2><p>图灵利用的如下几个条件来建立一些明文与密文的对应：</p><ol><li>德军在每天的固定时间会发送固定格式的密文，例如在每天早上六点会发送天气预报。由于固定格式，往往就有确定的单词出现，例如天气预报中会出现天气（德文wetter），这样就可以猜测这样的密文中一定存在特定的明文单词。</li><li>由于Enigma设计中反射器的存在，Enigma加密时一定不会把一个字母映射为字母本身。</li></ol><p>根据第一点，可以确定明文单词在密文中的大致位置，然后结合第二点，根据有没有字母映射到本身这一条件差不多可以确定明文的准确位置。下面的工作就是根据一些明文和对应的密文进行破解。</p><p>首先需要在已知明文中找到最小的一个字母循环圈。假设wetter对应的密文为ETJWPX，则这里存在W-&gt;E-&gt;T-&gt;W的循环圈。设在加密wetter前Enigma的状态为S，加密n个字母后为S+n。如果我们取三台机器，状态分别为S、S+1、S+3，将他们的输出与后者的输入依次相连，则S的W-&gt;S+1的E-&gt;S+3的T-&gt;S的W，构成了一条回路。</p><p>进一步，如果不考虑连接板，我们取三台机器，第一台状态记为S，调节第二台为S+1，调节第三台为S+3，按1-2-3-1的顺序输出与输入相连。如果其中不存在回路，则说明转子的状态与密钥不同。如果其中存在回路，则说明转子的状态很可能为密钥中转子的状态，同时这条回路很可能是字母循环圈。然后只需要用连接线把对应的字母对相连即可。例如，找到的字母循环圈为R-&gt;E-&gt;L-&gt;R，则用连接线连接R和W，L和T。至此密钥破解完成。</p><p>以上。</p><hr><p>参考资料：《Enigma的兴亡》</p>]]></content>
    
    <summary type="html">
    
      详细分析了对雷杰夫斯基和图灵破解Enigma的工作
    
    </summary>
    
      <category term="密码学" scheme="http://neverland.siyuan12.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="Enigma" scheme="http://neverland.siyuan12.com/tags/Enigma/"/>
    
      <category term="密码分析" scheme="http://neverland.siyuan12.com/tags/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Mac小工具集锦v1.0</title>
    <link href="http://neverland.siyuan12.com/2015/02/18/Mac%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6v1-0/"/>
    <id>http://neverland.siyuan12.com/2015/02/18/Mac小工具集锦v1-0/</id>
    <published>2015-02-17T16:00:00.000Z</published>
    <updated>2015-02-17T14:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>原本想写个完整的软件介绍，写着写着发现大部分都是废话。简洁有用至上，我就改写一些对提升效率有帮助的小工具吧。</p><ol><li>CheatSheet: 长按command键可以弹出当前所有可用的快捷键。熟记快捷键之后能够显著提高效率。</li><li>Alfred: 键盘流软件。熟练掌握可以极大减少鼠标和触控板的使用。目前Spotlight也在往类似的方向转变。</li><li>Moom: 用于窗口控制，弥补了OS X在分屏上相对于Windows的劣势，提供了丰富的分屏方案。拯救像在下一样，既不喜欢几个应用窗口重叠，也不喜欢自己折腾布局，而且还总是对不齐！！！强迫症福音。</li><li>XMind: 思维导图软件。图形化之后，很多混乱的事情就有救了，一图胜千言。</li><li>AntiRSI: 定时提醒你离开电脑休息一会儿，拯救颈椎病。</li><li>Scroll Reverser: 颠倒触控板和鼠标滚轮滑动的方向，可以与Windows保持一致。不过既然Mac如此的设计，个人不推荐修改。</li><li>smcFanControl: 监视CPU温度和风扇转速，也可以手动调节风扇转速。</li><li>CloudApp: 图床软件，可以上传小文件并生成引用或者下载链接。</li><li>AppCleaner: 用于卸载软件，卸载软件不只是在应用程序文件夹里删掉就好了喔。</li><li>AirServer: 利用AirPlay可以在电脑上提供iPhone和iPad的镜像。</li><li>VLC: 开源的视频播放软件，支持格式很丰富。</li><li>GoAgentX, ShadowsocksX: 翻墙用。嘘。</li><li>Jitouch: 自定义触控板手势，如果不习惯键盘流，这种方式也很方便。</li><li>Mou: Markdown编辑器。强烈建议所有人学习Markdown，文档的内容既条理清晰，生成的PDF或者网页也很漂亮，省去排版的烦恼。</li><li>Deckset: 用Markdown做演示文稿。由于Markdown语法很简单，加上模板很棒，快速制作简单的演示文稿会比Pages和PPT更方便。</li></ol><p>以后再补充吧~</p>]]></content>
    
    <summary type="html">
    
      介绍Mac上一些的小工具
    
    </summary>
    
      <category term="Mac" scheme="http://neverland.siyuan12.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://neverland.siyuan12.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>第一份作品</title>
    <link href="http://neverland.siyuan12.com/2015/01/08/%E7%AC%AC%E4%B8%80%E4%BB%BD%E4%BD%9C%E5%93%81/"/>
    <id>http://neverland.siyuan12.com/2015/01/08/第一份作品/</id>
    <published>2015-01-08T11:07:17.000Z</published>
    <updated>2015-04-22T17:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>揪心的半个月过去一周多了。回想起来，也就那样。</p><p>波澜起伏的一周过去了。体会到了开发的紧张，上线前的焦急，上线时的忐忑，现场的失望，回顾的释然。</p><p>开心也好，辛苦也罢。所有的情感在那个跨年夜都被无限放大，又在一周之后被无限缩小。时间会抹平一切无关的情感。</p><p>看到了自己的能量，也看到了自己能力的鸿沟。</p><p>我想我现在还没有看到一个足够好的范例。我想我再多尝试也看不到答案。我想我应该尽早走出去，在更强更专业的团队里打拼，跳起来看看自己的上限在哪里。</p><p>考试都要加油。</p>]]></content>
    
    <summary type="html">
    
      我的第一次，给了这个忘不了的跨年夜。
    
    </summary>
    
      <category term="随想" scheme="http://neverland.siyuan12.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="http://neverland.siyuan12.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="软件工程" scheme="http://neverland.siyuan12.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Monad初探</title>
    <link href="http://neverland.siyuan12.com/2014/12/22/Monad%E5%88%9D%E6%8E%A2/"/>
    <id>http://neverland.siyuan12.com/2014/12/22/Monad初探/</id>
    <published>2014-12-22T08:08:00.000Z</published>
    <updated>2014-12-22T08:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>我试图从如下的定义里看穿Monad的真相。不知道眼力够不够了😂</p><blockquote><p>A monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p><p>Monad是自函子范畴上的幺半群。</p></blockquote><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>首先，对于如下相关的概念我尝试给出我自己的定义。</p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>Haskell的类型系统相当复杂。不同于OO只是一层抽象，Haskell抽象多得可怕。目前我给出的分层如下：</p><p><img src="/BlogImages/Monad初探/Monad_1.png" alt=""></p><p>从下往上是按照从具体到抽象。首先是具体的值<code>Value</code>，其次是将<code>Value</code>抽象为特定类型<code>Proper Type</code>，然后<code>Proper Type</code>又被抽象为高阶(包含一阶)类型<code>Higher Order Type</code>，最后是最抽象的<code>kind</code>。而<code>Monad</code>是什么呢？它是<code>kind</code>为<code>* -&gt; *</code>的一种类型类。</p><h3 id="函数与函子"><a href="#函数与函子" class="headerlink" title="函数与函子"></a>函数与函子</h3><blockquote><p>此处的函数狭义地仅指Haskell里的方法，即输入参数和输出参数均为<code>Proper Type</code>的一一映射</p></blockquote><p>函数<code>Function</code>是指输入参数和输出参数均为<code>Proper Type</code>的一一映射，而函子<code>Functor</code>是指输入参数和输出参数均为<code>Higher Order Type</code>的一一映射。其中<code>Functor</code>的定义不够准确，在范畴部分会继续补充。</p><h3 id="自函数与自函子"><a href="#自函数与自函子" class="headerlink" title="自函数与自函子"></a>自函数与自函子</h3><p>前面我们已经给出了<code>Function</code>的定义，用代码表示就是<code>Type A -&gt; Type B</code>。如果此处的<code>Type B</code>包含于<code>Type A</code>，那么我们就称此函数为自函数<code>Endofunction</code>。特别的，如果<code>Type B</code>等于<code>Type A</code>，则称其为<code>Identity Function</code>。</p><p>类比自函数，什么是自函子<code>Endofunctor</code>呢？对于<code>Higher Order Type A -&gt; Higher Order Type B</code>，如果<code>Higher Order Type B</code>包含于<code>Higher Order Type A</code>，则我们称此函子为自函子。同样的，如果<code>Higher Order Type B</code>等于<code>Higher Order Type A</code>，则称其为<code>Identity Functor</code>。</p><h3 id="范畴"><a href="#范畴" class="headerlink" title="范畴"></a>范畴</h3><p>我不打算从很严谨的定义阐明范畴<code>Category</code>的概念。通俗地讲，我理解的范畴就是对象+态射。那么在Haskell中什么是范畴呢？</p><p>最重要的我认为是一个<code>Higher Order Type</code>对应于一个<code>Category</code>，其中被该<code>Higher Order Type</code>所抽象的<code>Proper Type</code>就是该<code>Category</code>的对象，而以这些<code>Proper Type</code>为入参和出参的<code>Function</code>就是该<code>Category</code>的态射。</p><h3 id="函子深入"><a href="#函子深入" class="headerlink" title="函子深入"></a>函子深入</h3><p>然后<code>Functor</code>的概念可以进一步深入。刚刚说道，函子<code>Functor</code>是指输入参数和输出参数均为<code>Higher Order Type</code>的一一映射，更准确的，<code>Functor</code>是<code>Higher Order Type</code>所对应的范畴之间的映射，它包括对对象的映射和对态射的映射。举个例子，考虑<code>a -&gt; [a]</code>作为<code>Functor</code>，它是<code>Identity</code>对应的范畴和<code>List</code>对应的范畴之间的映射。第一它可以作为对象之间的映射，例如它是<code>Int -&gt; [Int]</code>之间的映射，第二，作为对态射的映射，由于<code>[]</code>有<code>map</code>方法，所以它还是<code>(Int -&gt; Int) -&gt; [Int] -&gt; [Int]</code>之间的映射。</p><blockquote><p>在Haskell中有类型类<code>Functor</code>，它接受高阶类型作为实例，高阶类型本身就是类型构造器，它就是对象之间的映射。<code>Functor</code>实例必须实现<code>fmap</code>方法，它又是态射之间的映射。</p></blockquote><h3 id="半群与幺半群"><a href="#半群与幺半群" class="headerlink" title="半群与幺半群"></a>半群与幺半群</h3><p>我们知道群是指满足的封闭性、结合律、有幺元、逆元的非空集合+二元运算<code>(G, *)</code>。当<code>(G, *)</code>满足封闭性、结合律时它是一个半群，进一步，如果还有幺元，则它是一个幺半群。</p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>上面说了一大堆，如果不具体到Monad的定义上被觉得都是扯淡。回顾开头部分引用的定义。</p><blockquote><p>Monad是自函子范畴上的幺半群。</p></blockquote><h3 id="自函子范畴"><a href="#自函子范畴" class="headerlink" title="自函子范畴"></a>自函子范畴</h3><p>首先，考虑什么是自函子范畴？上面说过，粗浅地认为范畴=对象+态射。既然是自函子范畴，对象自然是自函子。而实际上如果把Haskell所有类型和方法统一作为一个范畴，则Haskell上所有的函子都是自函子（<strong>这一点还有些模糊</strong>）。用Haskell代码表示这里的自函子就是<code>a -&gt; m b</code>，其中<code>a, b</code>是类型参数，<code>m</code>是高阶类型。</p><p>那么接下来的问题就是自函子范畴上的态射是什么。根据函子范畴的定义，这里的态射叫做自然变换。维基上的解释还比较清晰，用Haskell代码表示从函子<code>a - &gt; m b</code>到<code>a -&gt; m c</code>的自然变换就是<code>m b -&gt; m c</code>。所有这些自然变换就构成了自函子范畴上的态射。</p><h3 id="自函子范畴上的幺半群"><a href="#自函子范畴上的幺半群" class="headerlink" title="自函子范畴上的幺半群"></a>自函子范畴上的幺半群</h3><p>然后作为这个自函子范畴上的幺半群<code>(G, *)</code>，非空集合G自然就是自函子构成的集合，而二元运算<code>*</code>是什么呢？幺元是什么呢？</p><p>回忆Haskell中对Monad实例的要求是实现<code>return</code>函数和<code>&gt;&gt;=</code>函数，它们的定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> (<span class="title">m</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    return :: a -&gt; m a</span><br></pre></td></tr></table></figure><p>根据函数声明可以看出，<code>return</code>本身就是一个特殊的自函子，而<code>&gt;&gt;=</code>酷似二元运算。我们自然地猜测<code>&gt;&gt;=</code>就是这个幺半群的二元运算，<code>reutrn</code>就是幺元。但是<code>&gt;&gt;=</code>并不完全符合二元运算的定义，所以我们定义新的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;=&gt; :: (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span><br></pre></td></tr></table></figure><p>显然，<code>&gt;=&gt;</code>符合这个幺半群里对二元运算的定义。<code>&gt;&gt;=</code>与<code>&gt;=&gt;</code>的关系为对于任意两个函子<code>f, g</code>，有<code>(f x) &gt;&gt;= g</code>等价于<code>(f &gt;=&gt; g) x</code>。</p><h4 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h4><p><del>对于任意两个自函子<code>f: a -&gt; m b</code>以及<code>g: b -&gt; m c</code>，那么<code>&gt;&gt;= g</code>就是一个<code>m b -&gt; m c</code>的自然变换，将<code>f</code>映射为<code>h: a -&gt; m c</code>，而显然<code>h</code>也是一个自函子，所以满足封闭性。用代码表示就是<code>(&gt;&gt;= g) . f = h</code>。</del></p><p>对于任意两个自函子<code>f: a -&gt; m b</code>以及<code>g: b -&gt; m c</code>，那么<code>f &gt;=&gt; g</code>得到<code>h: a -&gt; m c</code>的自然变换，而显然<code>h</code>也是一个自函子，所以满足封闭性。</p><h4 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h4><p><del>对于任意三个自函子<code>f: a -&gt; m b</code>, <code>g: b -&gt; m c</code>, <code>h: c -&gt; m d</code>，先考虑<code>(f * g) * h</code>的顺序，计算<code>(&gt;&gt;= h) . ((&gt;&gt;= g) . f) = a - &gt; m d</code>。再考虑<code>f * (g * h)</code>的顺序，计算<code>(&gt;&gt;= (&gt;&gt;= h) . g) . f = a - &gt; m d</code>。所以结合律成立。</del></p><p>对于任意三个自函子<code>f: a -&gt; m b</code>, <code>g: b -&gt; m c</code>, <code>h: c -&gt; m d</code>，先考虑<code>(f * g) * h</code>的顺序，计算<code>(f &gt;=&gt; g) &gt;=&gt; h = a - &gt; m d</code>。再考虑<code>f * (g * h)</code>的顺序，计算<code>f &gt;=&gt; (g &gt;=&gt; h) = a - &gt; m d</code>。所以结合律成立。</p><h4 id="幺元"><a href="#幺元" class="headerlink" title="幺元"></a>幺元</h4><p><del>首先验证左结合律。取任意自函子<code>f: a -&gt; m b</code>，考虑<code>return * f</code>，计算<code>(&gt;&gt; f) . return = a -&gt; m b = f</code>。左结合律成立。再验证右结合律，考虑<code>f * return</code>，计算<code>(&gt;&gt;= return) . f = a -&gt; m b = f</code>，右结合律成立。</del></p><p>首先验证左结合律。取任意自函子<code>f: a -&gt; m b</code>，考虑<code>return * f</code>，计算<code>return &gt;=&gt; f = a -&gt; m b = f</code>。左结合律成立。再验证右结合律，考虑<code>f * return</code>，计算<code>f &gt;=&gt; return = a -&gt; m b = f</code>，右结合律成立。</p><p>综上，我们验证了实现了<code>return</code>和<code>&gt;=&gt;</code>(也就是实现了<code>return</code>和<code>&gt;&gt;=</code>)的Monad实例确实是自函子范畴上的幺半群。这里我们暂时不再证明满足自函子范畴上的幺半群一定是Monad的结论。</p><h2 id="Monad有什么用"><a href="#Monad有什么用" class="headerlink" title="Monad有什么用"></a>Monad有什么用</h2><p>费尽千辛万苦终于理解了开头一句话的意思，但现在面临的问题是引入Monad究竟给Haskell带来了什么好处呢？无非是解决非纯函数带来的副作用的问题。</p><p>那么Monad怎么解决副作用问题呢？</p><p>在维基百科的Haskell词条中有如下描述：</p><blockquote><p>它是一门纯函数编程语言，这意味着大体上，Haskell中的函数没有副作用。Haskell用特定的类型来表达副作用，该类型与函数类型相互独立。纯函数可以操作并返回可执行的副作用的类型，但不能够执行它们，只有用于表达副作用的类型才能执行这些副作用，Haskell以此表达其它语言中的非纯函数。</p></blockquote><p>按照我的理解，Haskell对于这些可能有副作用的类型构造了相应的高级类型<code>Higher Order Type</code>，也就是形成了对立于没有副作用的范畴的新范畴。而在这两个范畴之间，通过Monad联系起来。若记无副作用范畴为C1，有副作用范畴为C2。这种联系只有从C1到C2的单向方法以及C2的内部方法，不存在从C2到C1的方法。通过这样的设计来隔离这两个范畴。</p><p>还是最初以导致Monad引入的IO类型作为例子说明。</p><p>这里的自函子为<code>IO</code>函子，它对Monad类型类的实现如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    return x = <span class="type">IO</span> x</span><br><span class="line">    <span class="type">IO</span> x &gt;&gt;= f = f x</span><br></pre></td></tr></table></figure><p>IO是显然的具有副作用的操作。IO类型将这种操作封装为一种类型，<code>return</code>操作提供了从C1到C2的方法，<code>&gt;&gt;=</code>操作提供了C2的内部方法。更准确的说法是道可叨中的说法：<code>return</code>是一种最自然的类型提升，也就是单位函子，<code>&gt;&gt;=</code>是一种首先的类型下降，但是确保了结果还是在IO类型的范畴当中。</p><p>通过Monad的机制，确保了有副作用的范畴中的执行始终停留在有副作用的范畴中，不会影响原来的类型。</p><p>最后我想补充一点，Monad是如何解决执行顺序对于有副作用函数的影响。我的理解是<code>&gt;&gt;=</code>实际上类似于shell中的<code>|</code>，它构造了一种管道，使得函数的执行是有顺序的。但是这与幺半群的结合律是否矛盾呢？并不矛盾。因为例如对于<code>m &gt;&gt;= f &gt;&gt;= g ...</code>中除了第一个参数，后续的部分只是明确了执行的过程，并没有实际的输入执行，必须等到<code>m</code>进入管道后才能真正开始计算结果。所以与结合律并不矛盾。</p><p>引用道可叨的一张图，希望能帮助理解。</p><p><img src="/BlogImages/Monad初探/Monad_2.png" alt=""></p><!--> 原本我觉得上面这一段中提出执行顺序问题，是可以在前面关于隔离两个范畴的讨论中解决掉的，但是并没能太想清楚--><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>有道寒假实践题目是调查自己的家族图谱。如果我们构想了一个数据结构存储了所有收集到的关于一个族谱的信息。从其中某一个人出发，要获得与他相关的任意一个人，可以经过一步或者多步如下的关系获得：父亲(father)，母亲(mother)，丈夫或妻子(husbandOrWife)，长子或长女(eldestChild)，最大的弟弟或妹妹(nextChild)</p><p>于是我构造了如下的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> <span class="type">String</span></span></span><br><span class="line">              <span class="keyword">deriving</span> <span class="type">Show</span></span><br><span class="line"><span class="title">father</span> :: <span class="type">Person</span> -&gt; <span class="type">Maybe</span> <span class="type">Person</span></span><br><span class="line"><span class="title">mother</span> :: <span class="type">Person</span> -&gt; <span class="type">Maybe</span> <span class="type">Person</span></span><br><span class="line"><span class="title">husbandOrWife</span> :: <span class="type">Person</span> -&gt; <span class="type">Maybe</span> <span class="type">Person</span></span><br><span class="line"><span class="title">eldestChild</span> :: <span class="type">Person</span> -&gt; <span class="type">Maybe</span> <span class="type">Person</span></span><br><span class="line"><span class="title">nextChild</span> :: <span class="type">Person</span> -&gt; <span class="type">Maybe</span> <span class="type">Person</span></span><br></pre></td></tr></table></figure><p>这里我们用了Monad类型的<code>Maybe</code>。它给我们带来了什么好处呢？由于不是每一个人都拥有上述五种关系的人，或者由于族谱的缺失，数据不一定完整。所以有可能经过上述某一步操作，没有期望的结果。如果我们采用对函数结果进行判断，则代码会演变成类似<code>If...else...</code>结构冗长的嵌套。<code>Maybe</code>由于实现了Monad类型，通过<code>&gt;&gt;=</code>我们可以正常地寻找某人，中间过程不用加以判断，如果某一步出现找不到，则结果会变为<code>Nothing</code>(不是说他不是东西。。。)。简直太有爱了！</p><p>从范畴角度来看，由于<code>Maybe</code>类型存在例外的<code>Nothing</code>的情况，所以Monad使得涉及<code>Maybe</code>的操作被限制在<code>Maybe</code>对应的范畴内，从而使程序设计变得容易。</p><p>写了这么多，我只想说。。。心好累。。。</p><p><br><br><br><br><br><br><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>我所理解的monad系列0-5 <a href="http://hongjiang.info/understand-monad-0/" target="_blank" rel="noopener">链接</a></li><li>道可叨 <a href="http://zhuoqiang.me/what-is-monad.html" target="_blank" rel="noopener">链接</a></li><li>自然变换 - 维基百科 <a href="http://zh.wikipedia.org/wiki/自然變換" target="_blank" rel="noopener">链接</a></li><li>知乎问题 - 如何解释Haskell中的单子？parker liu的回答 <a href="http://www.zhihu.com/question/22291305" target="_blank" rel="noopener">链接</a></li><li>Haskell/Understanding Monad <a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws" target="_blank" rel="noopener">链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      坑太深。。。学好数学真重要！！！
    
    </summary>
    
      <category term="Haskell" scheme="http://neverland.siyuan12.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://neverland.siyuan12.com/tags/Haskell/"/>
    
      <category term="Monad" scheme="http://neverland.siyuan12.com/tags/Monad/"/>
    
      <category term="范畴论" scheme="http://neverland.siyuan12.com/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python入门篇</title>
    <link href="http://neverland.siyuan12.com/2014/10/29/Python%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://neverland.siyuan12.com/2014/10/29/Python入门篇/</id>
    <published>2014-10-28T16:00:00.000Z</published>
    <updated>2015-02-17T13:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、语言特点"><a href="#一、语言特点" class="headerlink" title="一、语言特点"></a>一、语言特点</h2><ol><li>面向对象</li><li>平台无关</li><li>强类型语言<ul><li>强制数据类型定义，除非强制转换，数据类型不能改变，例如Python，C，C++，Java<blockquote><p>弱类型语言如Javascript，php</p></blockquote></li></ul></li><li>动态语言<ul><li>在运行期间才去做数据类型检查。不用给变量指定数据类型，该语言会在第一次给变量赋值时记录数据类型<blockquote><p>静态类型语言如C，C++，Java</p></blockquote></li></ul></li><li>解释性语言<ul><li>边翻译边执行，运行速度慢<blockquote><p>编译性语言会首先翻译，优化代码，运行速度快</p></blockquote></li></ul></li><li>脚本语言</li></ol><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote><p>type()可以返回变量类型</p></blockquote><ol><li>数值类型<ul><li>复数：j</li></ul></li><li>运算符<ul><li>幂运算：**</li></ul></li><li>布尔型<ul><li>操作：and or not</li></ul></li><li>字符串<ul><li>\：转移字符</li><li>r：使用原始串不转义 e.g. r’string\nstring’ =&gt; ‘string\nstring’</li><li>字符串操作：连接+, 复制*, 下标索引[]</li><li>字符串方法：count, 对齐函数[rjust, ljust, center], upper, lower, split, join, find, index, replace, isdigit, islower, isupper, startswith, endswith, strip, title</li><li>字符串格式化：e.g. “Number %i %f won!” %(12, 11.5)</li></ul></li><li>列表<ul><li>列表操作：连接+, 复制*, 下标索引[]</li><li>列表方法：append, extend, insert, remove, index, reverse, sort</li><li>遍历方法：<code>for item in example_list print item</code></li></ul></li><li>元组<ul><li>与列表相似，但不能修改，没有方法<blockquote><p><code>t = tuple(l)</code>：列表转换为元组<br><code>l = list(t)</code>：元组转换为列表</p></blockquote></li></ul></li><li>字典<ul><li>Key/Value值对</li><li>字典方法：clear, copy&amp;deepcopy, keys, values, items</li></ul></li></ol><blockquote><p>拷贝：对于列表、字典等类型（不包含数值类型和字符串类型）赋值代表引用，而不是拷贝。<br>a==b只比较值，a is b比较内存位置</p></blockquote><h2 id="三、变量和语句"><a href="#三、变量和语句" class="headerlink" title="三、变量和语句"></a>三、变量和语句</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><p>Python是动态语言，变量不指定类型。</p><h3 id="2-语句"><a href="#2-语句" class="headerlink" title="2. 语句"></a>2. 语句</h3><blockquote><p>同一层次的语句必须相同的缩进</p></blockquote><ul><li>if语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if a == b:</span><br><span class="line">print &quot;a == b&quot;</span><br><span class="line">elif a &gt; b:</span><br><span class="line">print &quot;a &gt; b&quot;</span><br><span class="line">else:</span><br><span class="line">print &quot;a &lt; b&quot;</span><br></pre></td></tr></table></figure><ul><li>while语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while true:</span><br><span class="line">print &quot;Hello&quot;</span><br></pre></td></tr></table></figure><ul><li>for语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">print &quot;Hello&quot;</span><br></pre></td></tr></table></figure><ul><li>break与continue语句</li></ul><h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><h3 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1. 函数基础"></a>1. 函数基础</h3><p>函数定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sum(a, b):</span><br><span class="line">return a + b</span><br></pre></td></tr></table></figure><p>函数调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = sum(1, 2)</span><br><span class="line">print r</span><br></pre></td></tr></table></figure><blockquote><p>特殊的参数传递方式：</p><ul><li>可以根据参数名进行参数传递</li><li>*args元组参数可以表示多个参数</li><li>**kwargs字典参数将多余的参数转为字典变量</li></ul><p>参数传递规则：</p><ol><li>非默认参数</li><li>默认参数</li><li>元祖参数（唯一）</li><li>字典参数（唯一）</li></ol></blockquote><h3 id="2-Lambda函数"><a href="#2-Lambda函数" class="headerlink" title="2. Lambda函数"></a>2. Lambda函数</h3><p>单行最小函数。e.g. (lambda x,y:x+y)(2,3)-&gt;5</p><h3 id="3-局部变量与全局变量"><a href="#3-局部变量与全局变量" class="headerlink" title="3. 局部变量与全局变量"></a>3. 局部变量与全局变量</h3><ol><li>通过参数传递时，数值类型和字符串类型为值传递，列表类型和字典类型为引用传递</li><li>函数体内用global可声明全局变量</li></ol><h3 id="4-包机制"><a href="#4-包机制" class="headerlink" title="4. 包机制"></a>4. 包机制</h3><p><code>from mymodule import function</code></p><h2 id="五、类"><a href="#五、类" class="headerlink" title="五、类"></a>五、类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class rectangle:</span><br><span class="line">def __init__(self, x, y):</span><br><span class="line">self.x = x</span><br><span class="line">self.y = y</span><br><span class="line">def area(self):</span><br><span class="line">return x * y</span><br></pre></td></tr></table></figure><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><ul><li>私有属性：__attr</li></ul><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><ul><li>普通类方法：只有对象（类实例）可见</li><li>静态方法@staticmethod：对类和对象可见<ul><li>不接受一个隐式的第一个参数</li></ul></li><li>类方法@classmethod：对类和对象可见<ul><li>接受一个隐式的第一个参数</li></ul></li></ul><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class rectanglee(shape):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="六、文件读写"><a href="#六、文件读写" class="headerlink" title="六、文件读写"></a>六、文件读写</h2><ol><li>f=file/open(path, “w”/“r”/“a”)</li><li>f.close()</li><li>f.read()/readline()/readlines()</li><li>f.write()/writeline()/writelines()</li><li>f.tell(), f.seek(offset, position)</li></ol>]]></content>
    
    <summary type="html">
    
      本篇为Python学习笔记入门篇，适用于有一定C/C++基础的Python初学者。主要介绍Python语言的一些特性，语法方面主要记录了与C/C++有差异的地方
    
    </summary>
    
      <category term="Python" scheme="http://neverland.siyuan12.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://neverland.siyuan12.com/tags/Python/"/>
    
      <category term="学习笔记" scheme="http://neverland.siyuan12.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
