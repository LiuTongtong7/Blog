<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>virtualenv | 更新Python后如何修复virtualenv</title>
      <link href="/2018/03/12/09.virtualenv%20%7C%20%E6%9B%B4%E6%96%B0Python%E5%90%8E%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0virtualenv/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：在升级了Python后，由于Python路径变更，virtualenv中的symlinks将被破坏，本文提供了脚本来修复这个问题。</p></blockquote><a id="more"></a><h2 id="01-运行环境和问题原因"><a href="#01-运行环境和问题原因" class="headerlink" title="01. 运行环境和问题原因"></a>01. 运行环境和问题原因</h2><p>在MBP上，我使用的是Homebrew安装的Python2和Python3，使用<code>virtuanenvwrapper</code>管理Python的虚拟环境（虚拟环境保存位置<code>$WORKON_HOME=$HOME/.virtualenvs</code>）。</p><p>当brew更新了Python后，再次进入虚拟环境并运行Python时会得到类似如下的错误：</p><pre><code>dyld: Library not loaded: @executable_path/../.Python  Referenced from: /your/home/.virtualenvs/virtualenv_name/bin/python  Reason: image not found</code></pre><p>执行<code>ls -la ~/.virtualenvs/virtualenv_name/.Python</code>会发现</p><pre><code>/your/home/.virtualenvs/virtualenv_name/.Python -&gt; /usr/local/Cellar/python@2/2.7.XX_X/Frameworks/Python.framework/Versions/2.7/Python</code></pre><p>virtualenv崩溃的原因在于，由于symlinks的路径包含了版本号，更新之后会导致symlinks失效。</p><h2 id="02-解决办法"><a href="#02-解决办法" class="headerlink" title="02. 解决办法"></a>02. 解决办法</h2><p>参考<a href="https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs" target="_blank" rel="noopener">StackOverflow中的相关问题</a>后，发现利用下面的语句可以修复virtuanenv中损坏的symlinks</p><pre><code>find ~/.virtualenvs/virtualenv_name/ -type l -deletevirtualenv ~/.virtualenvs/virtualenv_name</code></pre><p>或者</p><pre><code>gfind ~/.virtualenvs/virtualenv_name/ -type l -xtype l -deletevirtualenv ~/.virtualenvs/virtualenv_name</code></pre><p>不过，如果你有较多的虚拟环境，挨个更新就显得非常繁琐。更重要的问题是，如果你的虚拟环境中使用的Python版本既有Python2也有Python3，还有些虚拟环境包含了系统全局的packages，第二条语句就得加上参数<code>-p pythonX</code>和<code>--system-site-packages</code>。</p><p>为了彻底解决这个烦恼，尝试编写脚本来修复virtuanenv。为了判定如何重新创建虚拟环境，做了如下规定：</p><ul><li>在文件名的末尾通过<code>2</code>和<code>3</code>来区分虚拟环境中Python的版本（要求文件名中间不包含这两个数字），例如<code>Jupyter2</code>和<code>Jupyter3</code>；</li><li>在文件名的末尾加上<code>@</code>来表示包含系统全局的packages，例如<code>Jupyter2@</code>。</li></ul><p>脚本的思路为：</p><ol><li>执行virtualenvwrapper.sh（为了能够执行<code>workon</code>）</li><li>执行<code>workon</code>来获得虚拟环境的列表</li><li>遍历每个虚拟环境<ol><li>删除该环境中损坏的symlinks</li><li>根据虚拟环境的名称来确定virtualenv的参数</li><li>重新创建virtualenv</li></ol></li></ol><h2 id="03-脚本代码"><a href="#03-脚本代码" class="headerlink" title="03. 脚本代码"></a>03. 脚本代码</h2><p>脚本的代码如下，代码也可以在<a href="https://github.com/LiuTongtong7/Snippets/blob/master/update_virtualenv.sh" target="_blank" rel="noopener">我的Github</a>中查看。</p><pre><code class="bash">#!/bin/bashsource virtualenvwrapper.shfor env_name in $(workon); do    echo ${env_name}    env_path=&quot;${WORKON_HOME}/${env_name}&quot;    gfind ${env_path} -type l -xtype l -delete    python_flag=&quot;&quot;    if [[ ${env_name} =~ &quot;3&quot; ]]; then        python_flag=&quot;-p python3&quot;    else        python_flag=&quot;-p python2&quot;    fi    ssp_flag=&quot;&quot;    if [[ ${env_name} =~ &quot;@&quot; ]]; then        ssp_flag=&quot;--system-site-packages&quot;    fi    echo &quot;virtualenv ${python_flag} ${ssp_flag} ${env_path}&quot;    virtualenv ${python_flag} ${ssp_flag} ${env_path}done</code></pre><h2 id="04-参考资料"><a href="#04-参考资料" class="headerlink" title="04. 参考资料"></a>04. 参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs" target="_blank" rel="noopener">Broken references in Virtualenvs - StackOverflow</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> virtualenv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>撒币游戏 | 一次有趣的博弈论实践</title>
      <link href="/2018/01/24/06.%E6%92%92%E5%B8%81%E6%B8%B8%E6%88%8F%20%7C%20%E4%B8%80%E6%AC%A1%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AE%9E%E8%B7%B5/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：最近，借着生日的契机，在公众号里进行了一次「撒币」游戏。让我们回顾一下这次游戏里有哪些有趣的事情吧。</p></blockquote><a id="more"></a><p>最近，借着生日的契机，在<a href="/BlogImages/撒币游戏/公众号二维码.jpg" target="_blank">我的公众号</a>里进行了一次「撒币」游戏。原本是在微观经济学课上玩过一个类似的游戏，突然奇想就亲自组织了一次。让我们回顾一下这次游戏里有哪些有趣的事情吧。</p><h2 id="01-游戏规则"><a href="#01-游戏规则" class="headerlink" title="01. 游戏规则"></a>01. 游戏规则</h2><blockquote><p>本次撒币游戏的规则如下：在本号后台回复1-100的一个整数即可参与，活动结束后，回复没有与其他人重复的最大数字的同学即为本次的赢家，可以获得价格等于该数字的红包或礼物。</p></blockquote><p>从规则中可以看出玩家的<strong>报酬</strong>情况是，获胜玩家的报酬等于其选择的数字，其余玩家报酬为0。当然，存在一种特殊情况是，如果所有数字均有重复，则无人获得奖金，庄家是唯一赢家。为了分析方便，我们认为此时所有人的报酬是负数，即所有人都会厌恶从而避免这种情况。</p><h2 id="02-条件分析"><a href="#02-条件分析" class="headerlink" title="02. 条件分析"></a>02. 条件分析</h2><p>从游戏的规则设定中，我们可以知道什么呢？</p><ul><li>虽然所有人做出决策的时刻不同，但由于截止时间前每个人的决策结果对其他人是不可见的，所以游戏的过程可以视为一次<strong>静态博弈</strong>。</li><li>每个人的预期报酬是由自己所选的数字决定的，报酬的定价机制会激励玩家选更大的数字。</li><li>结合游戏规则可以看出，<strong>越少</strong>的玩家参与，每个玩家获胜的几率都会越高，没有激励会使得玩家转发这次游戏，所以这次游戏是几乎没有二次<strong>传播性</strong>的（忧伤）。</li><li>果然，从推送的阅读量可以估计出游戏的<strong>参与人数</strong>基本是100以内（忧伤x2），可以断定绝大多数玩家都是庄家TT的一度联系人，由此可以推出玩家群体中应该存在多个互相熟悉的社交圈。再考虑到奖金的可分性，于是存在<strong>合作</strong>的可能性。</li><li>由于规则没有禁止玩家间的交流，每名玩家可以通过线上或线下的渠道发表任意的观点，玩家间的<strong>交流</strong>是可能的。</li></ul><h2 id="03-策略设计"><a href="#03-策略设计" class="headerlink" title="03. 策略设计"></a>03. 策略设计</h2><h3 id="一、不合作下的情况"><a href="#一、不合作下的情况" class="headerlink" title="一、不合作下的情况"></a>一、不合作下的情况</h3><p>首先定义一下<strong>纳什均衡</strong>（Nash Equilibrium）的概念。对于一个博弈问题，如果固定其他所有人的策略，任一参与者不能通过改变自身的策略获得更好的报酬，就达到了一个纳什均衡。通俗地说就是，谁先动谁就输了。具体可以参见<a href="https://en.wikipedia.org/wiki/Nash_equilibrium" target="_blank" rel="noopener">维基</a>或<a href="https://baike.baidu.com/item/%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">百度</a>。</p><p>如果从“理性人”的假设出发，显然所有玩家决策的策略应该是一样的。如果每名玩家的策略是选择一个确定的数字，则所有玩家都会选择一样的数字，此时任意一名玩家选择另外一个数字，TA就成为了唯一的赢家（假设玩家数≥3），所以容易推出确定策略的均衡是不存在的（即不存在<strong>纯策略</strong>纳什均衡）。于是考虑混合策略。<strong>混合策略</strong>的决策是定义在策略集上的一个概率分布，比如以50%概率选100，50%概率选99。</p><p>由于玩家数量不确定，我们按照玩家数量从少到多逐步分析。</p><ul><li>如果只有2名玩家，容易知道在没有合作的情况下，每人的最优方案都是选100，是存在纯策略纳什均衡的。当玩家数≥3后，如上所述，纯策略的均衡就不存在了。</li><li>如果有3名玩家，情况复杂一些。尝试证明了一下，混合策略下的纳什均衡解是分布在1-100上的一个概率分布，每一个数字都有可能被选中，并且选择更大的数字概率更高（过程见附录）。</li><li>于是显然，当玩家数更多的时候，<strong>混合策略下的纳什均衡解同样也是1-100上的一个概率分布，选择大数的概率更高</strong>。</li></ul><p>不合作的情况下，能分析的内容到这里似乎就结束了。我猜多数人看到这里的想法是：这有什么用？（当然我没法验证这个想法。）这就反映了推理本身的出发点「理性人」的假设是不对的，在现实中，除了学习或者研究外，几乎没有人是具有能力并且愿意进行无限推理的。<strong>理性是有限的</strong>，才是更现实的情况。</p><h3 id="二、允许合作下的情况"><a href="#二、允许合作下的情况" class="headerlink" title="二、允许合作下的情况"></a>二、允许合作下的情况</h3><p>考虑如下的情况，有一名玩家A通过某种渠道告知游戏中其他所有玩家：我选了100。这时其他所有玩家会怎么做呢？如果选择100，自己就和A一起输掉了，这时候其他玩家就有机会获胜了；而如果所有人都不选择100，则A如果真的选择了100，就获胜了。那么是否会有人选择100呢？如果假设所有人是理性且自私的，在没有合作的情况下，是不会有人选择100的。</p><p>为了不让A获胜，该怎么办呢？于是<strong>合作和联盟</strong>出现了。B和C是室友，在商议之后决定，B选择100，C选择99，如果C获奖的话，BC平分奖金。通过这种策略，BC的联盟成功击败了A这种看似必胜的策略，并且任一单独的玩家是不可能战胜BC的联盟的。<strong>合作博弈下，联盟通过降低联盟外玩家的胜率，提高了自己内部的胜率。</strong>那么如果战胜BC的联盟呢？更大的联盟。DEF三人的联盟选择了98，99和100，BC联盟就失败了。</p><p>推广下去，更大的联盟就意味着更高的赢面。当玩家数不超过100时，<strong>必胜的方案是组织起一半的玩家，从大到小依次选择100, 99, 98…</strong>这时联盟外的玩家是不可能获胜的，联盟平分了奖金。当然，游戏的奖金金额能否激励大家去组织这样的事情，就是另外一个问题了，唉，穷。</p><h2 id="04-结果统计"><a href="#04-结果统计" class="headerlink" title="04. 结果统计"></a>04. 结果统计</h2><p>最终有<strong>50</strong>名有效的玩家参与了这次游戏，其中数据的茎叶图如下。最终获胜的是选择98数字的同学。</p><p><img src="/BlogImages/撒币游戏/撒币结果统计.png" alt="结果统计"></p><h2 id="05-结果分析"><a href="#05-结果分析" class="headerlink" title="05. 结果分析"></a>05. 结果分析</h2><p>从最后的数据中，我们可以看到些什么呢？</p><ul><li>有8名玩家选择了50以下的数字。由于奖励是与选择的数字挂钩的，无论从何种角度来看，这都不像理性人所作出的决策。为什么会出现这批玩家呢？我猜测是这样的金额不足以引起他们的兴趣，皮这一下的快乐远胜过金钱，所以…欢迎土豪们！</li><li>有20名玩家选择了50-89。由于没有实际采访过这些玩家，所以无法断定他们的动机。我的猜测是他们对整个游戏的<strong>玩家规模</strong>有着错误，具体来说是，过于乐观的估计，所以保守选择了偏小的数字，尤其是70-89的玩家。</li><li>剩下的22名玩家分布在91-100的区间内。这部分竞争颇为激烈，根据我在后台的观察，如果按照时间顺序列出获奖数字的话，是<strong>94-99-100-96-97-98</strong>，胜与负就在一念之间，激进的人群里偏保守的玩家笑到了最后。</li><li>除了分布，这个结果还能给我们什么样的启发呢？如果想赢的话，<strong>别选特殊数字</strong>。77（嗯很多人的幸运数字）、93、94（出生年份）、97（100内最大的质数）上发生了大量的撞车，就是最好的体现。当然，有些玩家是执意选择幸运数字的，这就是另一回事了。</li></ul><p><img src="/BlogImages/撒币游戏/撒币之玩家交流.jpg" alt="玩家例子"></p><p>除了结果外，游戏的过程中也发生了一些有趣的事情。在条件分析和策略设计里，我们提到，玩家间的交流是可能。在实际游戏过程中，真的出现了这样一位「戏精」同学，简直是读着剧本进行的演出：</p><ul><li>在自己的朋友圈内尽可能广播自己选择100的消息，</li><li>向其他人强调了选择100的同归于尽的后果，</li><li>以及，“本来不想分享的”充分证明了本次活动没有二次传播性（心累）。</li></ul><p>在知道TA最后选了啥之后…我决定颁发一枚「最佳戏精奖」👏</p><hr><p>这次的分析就到这里了。如果你有关于这次活动有什么想法，或者有什么新活动的点子，欢迎关注<a href="/BlogImages/撒币游戏/公众号二维码.jpg" target="_blank">我的公众号</a>跟我交流呀。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/39418994" target="_blank" rel="noopener">知乎 | 10个人各自从1-10选数字，尽量让自己最大且不重复，如何选？</a></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="三名玩家进行游戏的纳什均衡分析"><a href="#三名玩家进行游戏的纳什均衡分析" class="headerlink" title="三名玩家进行游戏的纳什均衡分析"></a>三名玩家进行游戏的纳什均衡分析</h3><p>按照每个人的策略集中的选项数进行分类讨论。显然选项数应该大于1。</p><ol><li>如果包含两种选项，则一定是100和99，假定最优的混合策略为以概率$p$选100，概率$1-p$选99。<ul><li>首先求解均衡策略。均衡时，选择100和99的预期报酬应该是一样的（即混合策略纳什均衡成立的条件），否则玩家一定会选择预期报酬更高的数字，混合策略就失效了。选择100的预期收益为$100(1-p)^2$，选择99的预期收益为$99p^2$，令它们相等。由于$100 \approx 99$，可以约掉，于是解出$p=0.5$，即50%概率选100，50%概率选99。如果所有人都选择该策略，则每个人获胜的概率为1/4，预期报酬为25。</li><li>下面需要验证一下，该策略是否是最优的。固定前两名玩家使用该策略，我们从第三名玩家的角度验证一下该策略是否可以改进。可以发现，如果三个人都选择一样的数字（概率为1/4），则没有人获胜，是否可以利用这种情况来提高自己的胜率呢？答案是可以的。例如，第三名玩家可以采用这样的混合策略：50%的概率选择100，各25%的概率选择99和98。稍加计算可以得出TA的获胜概率约5/16（认为$100 \approx 99 \approx 98$），大于1/4，则该策略不是纳什均衡的。</li><li>所以，不存在包含两种选项的均衡混合策略。</li></ul></li><li>如果包含三种选项，则一定是100，99和98。用类似的方式求解，依然可以发现该策略也不是最优的，存在包含四种选项的解可以严格更优。</li><li>于是猜想均衡时的混合策略，在1-100中所有数字上都应该有概率选中。采用反证法证明。如果两名玩家只选中部分数字，则第三名玩家可以通过利用前两人选中一样数字的情况来提高自己的胜率。此猜想可以证明如下：<ol><li>假设均衡策略包含数字$n_1 &gt; n_2 &gt; \ldots &gt; n_m$，在其上的概率分布为$p_1, \ldots, p_m$，$\forall i = 1, 2, \ldots, m, p<em>i &gt; 0, \sum</em>{i=1}^m p_i=1$，其中$m&lt;100$</li><li>根据均衡条件，可知对于任意一名玩家，在$n_1, n_2, \ldots, n_m$中选择任一数字，获胜的概率都是$(1-p_1)^2$，所以按照此策略，每名玩家的预期胜率都是$(1-p_1)^2$</li><li>因为$m<100$，存在1-100中的某个整数$n'$不在$n_1, n_2,="" \ldots,="" n_m$中，假设$n_k="">n'>n_{k+1}$（如果$k=m$，则$n_k&gt;n’$）</100$，存在1-100中的某个整数$n'$不在$n_1,></li><li>现固定前两名玩家的策略，设计第三名玩家的策略如下：选择$n_1$的概率为$p_1’=p_1-p’$，选择$n’$的概率为$p’$，其中$0<p'<p_1$，选择其他数字的概率不变。可以推得此玩家的胜率为$$(1-p_1)^2 *="" (1-p')="" +="" (p_1^2+…+p_k^2+(1-p_1-…-p_k)^2)="" p'.$$="" 根据均衡条件，选择$n_1$和$n_k$的胜率应当相同，所以有$$(1-p_1)^2="p_1^2+…+p_k-1^2+(1-p_1-…-p_k)^2,$$" 所以胜率为="" $$\begin{eqnarray*}="" &&(1-p_1)^2="" p'="" \\="" &="&(1-p_1)^2" ((1-p_1)^2+p_k^2)="" p_k^2="">&amp; (1-p_1)^2 \end{eqnarray*}$$</p'<p_1$，选择其他数字的概率不变。可以推得此玩家的胜率为$$(1-p_1)^2></li><li>所以该策略不是均衡策略，假设不成立。又由于纳什证明了每个玩家策略是有限种的情况下，纳什均衡一定存在，所以均衡策略在1-100中所有数字上都应该有概率选中，证毕。</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Azure | 批量获取Azure Blob列表</title>
      <link href="/2018/01/15/07.Azure%20%7C%20%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96Azure-Blob%E5%88%97%E8%A1%A8/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：介绍如何利用Azure Python SDK批量提取Blob的列表。</p></blockquote><a id="more"></a><p>最近碰到朋友的一个需求，要从Azure Blob Storage中获取所有图片的文件名列表，量级大约在百万左右。</p><h2 id="01-GUI工具"><a href="#01-GUI工具" class="headerlink" title="01. GUI工具"></a>01. GUI工具</h2><p>由于之前并没有接触过Azure，一时间没有思路。于是做了以下的尝试，但都失败了：</p><ol><li>Microsoft官方提供的GUI - Azure Storage Explorer：在GUI界面里只能看到一个Container里的1000个文件，其余就不能加载了。</li><li>Azure的Portal：与GUI类似，加载的数量有限，无法批量获取。</li><li>第三方GUI - Azure Management Studio：在网上找到的第三方提供的GUI，功能比Azure Storage Explorer强大很多。右击某个文件夹有一个导出Blob List的选项，但是当文件夹中的文件数量超过一定阈值时，导出会失败。（据我个人推测，与Azure的API每次获取文件的数量有关，超过这个数量就不能导出了）</li></ol><h2 id="02-Azure-SDK"><a href="#02-Azure-SDK" class="headerlink" title="02. Azure SDK"></a>02. Azure SDK</h2><p>现有的GUI工具直接获取的思路行不通，于是我开始尝试利用Azure提供的SDK进行爬取。在<a href="https://docs.microsoft.com/en-us/azure/storage/" target="_blank" rel="noopener">Azure的官方文档</a>中，How to - Develop部分列出了Azure支持的开发方式，除了网上其他资源主要说的<code>.NET</code>外，还包括<code>Java</code>、<code>C++</code>、<code>Python</code>、<code>PHP</code>等几乎所有常见的语言，甚至还支持<code>REST</code>方式（官方样例使用的是<code>C#</code>）。</p><p>本着“能写一个脚本解决的事情，绝不搞得太复杂”的原则，选择使用Python SDK进行操作。幸运的是，在<a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-python-how-to-use-blob-storage" target="_blank" rel="noopener">Python SDK的介绍</a>中，刚好有一个小节是”List the blobs in a container“，给出的示例代码如下：</p><pre><code class="Python">generator = block_blob_service.list_blobs(&#39;mycontainer&#39;)for blob in generator:    print(blob.name)</code></pre><p>以为可以直接搞定，但是发现返回的结果只有5000张图片。看来介绍里的内容不够完整，于是去阅读<a href="http://azure-storage.readthedocs.io/index.html" target="_blank" rel="noopener">Azure Python SDK的文档</a>，找到了<a href="http://azure-storage.readthedocs.io/ref/azure.storage.blob.baseblobservice.html" target="_blank" rel="noopener">关于list_blobs函数的说明</a>：</p><blockquote><p>list_blobs(container_name, prefix=None, num_results=None, include=None, delimiter=None, marker=None, timeout=None)</p><p>Returns a generator to list the blobs under the specified container. The generator will lazily follow the continuation tokens returned by the service and stop when all blobs have been returned or num_results is reached.</p><p>If num_results is specified and the account has more than that number of blobs, the generator will have a populated next_marker field once it finishes. This marker can be used to create a new generator if more results are desired.</p><p>Parameters:    </p><ul><li>container_name (str) – Name of existing container.</li><li>prefix (str) – Filters the results to return only blobs whose names begin with the specified prefix.</li><li><strong>num_results</strong> (int) – Specifies the maximum number of blobs to return, including all BlobPrefix elements. If the request does not specify num_results or specifies a value greater than <strong>5,000</strong>, the server will return up to 5,000 items. Setting num_results to a value less than or equal to zero results in error response code 400 (Bad Request).</li><li>include (Include) – Specifies one or more additional datasets to include in the response.</li><li>delimiter (str) – When the request includes this parameter, the operation returns a BlobPrefix element in the result list that acts as a placeholder for all blobs whose names begin with the same substring up to the appearance of the delimiter character. The delimiter may be a single character or a string.</li><li><strong>marker</strong> (str) – An opaque continuation token. This value can be retrieved from the <strong>next_marker</strong> field of a previous generator object if num_results was specified and that generator has finished enumerating results. If specified, this generator will begin returning results from the point where the previous generator stopped.</li><li>timeout (int) – The timeout parameter is expressed in seconds.</li></ul></blockquote><p>发现了问题的关键所在：<code>list_blobs</code>每次返回的数量由<code>num_results</code>控制，至多为5,000，如果遍历尚未结束，则返回的结果中会有名为<code>next_marker</code>的field，在下一次调用<code>list_blobs</code>时将上一次调用结果里<code>next_marker</code>的值作为参数<code>marker</code>的值，则可以从上一次遍历结束的位置之后继续获取。于是，问题解决了。</p><h2 id="03-优化"><a href="#03-优化" class="headerlink" title="03. 优化"></a>03. 优化</h2><p>写完脚本心满意足地开始运行时，发现速度感人，全部跑完大约需要60多个小时。由于原来图片是分别存放在多个文件夹中的，自然的想法就是并行化。将原来的任务打散，每个线程获取一个文件夹中的内容，最终大约花费两个小时的时间爬取了约100万个文件。</p><h2 id="04-代码"><a href="#04-代码" class="headerlink" title="04. 代码"></a>04. 代码</h2><p>下面代码完成的功能是利用多线程（每个线程每次爬取的文件数为1000），爬取Azure Blob Container中名称为<code>beijingXXX</code>（XXX为001-100）的文件夹中所有文件的文件名，将结果保存在对应的<code>beijingXXX.txt</code>文件中。</p><p>代码也可以在<a href="https://github.com/LiuTongtong7/Snippets/blob/master/Azure/list_blobs.py" target="_blank" rel="noopener">我的Github</a>中查看。</p><pre><code class="Python">#!/usr/bin/python2# -*- coding:utf-8 -*-import multiprocessingimport osimport timefrom azure.storage.blob import BlockBlobServiceCONFIG = {    &#39;account_name&#39;: &#39;your_accout_name&#39;,    &#39;account_key&#39;: &#39;your_account_key&#39;,    &#39;container_name&#39;: &#39;your_container_name&#39;}NUM_PER_ITERATION = 1000def list_blobs(folder):    block_blob_service = BlockBlobService(account_name=CONFIG[&#39;account_name&#39;], account_key=CONFIG[&#39;account_key&#39;])    fp = open(folder + &#39;.txt&#39;, &#39;a+&#39;)    counter = 0    print &quot;{} - {} - COUNT {}&quot;.format(folder, time.asctime(time.localtime()), counter)    blob_list = list()    generator = block_blob_service.list_blobs(container_name=CONFIG[&#39;container_name&#39;], prefix=folder,                                              num_results=NUM_PER_ITERATION)    for blob in generator:        blob_list.append(blob.name)    fp.write(&#39;\n&#39;.join(blob_list) + &#39;\n&#39;)    next_marker = generator.next_marker    counter += len(blob_list)    print &quot;{} - {} - COUNT {}&quot;.format(folder, time.asctime(time.localtime()), counter)    while next_marker:        blob_list = list()        generator = block_blob_service.list_blobs(container_name=CONFIG[&#39;container_name&#39;], prefix=folder,                                                  num_results=NUM_PER_ITERATION, marker=next_marker)        for blob in generator:            blob_list.append(blob.name)        fp.write(&#39;\n&#39;.join(blob_list) + &#39;\n&#39;)        next_marker = generator.next_marker        counter += len(blob_list)        print &quot;{} - {} - COUNT {}&quot;.format(folder, time.asctime(time.localtime()), counter)    fp.close()if __name__ == &#39;__main__&#39;:    print time.asctime(time.localtime()) + &quot; PID: {}&quot;.format(os.getpid())    folders = list()    for i in range(1, 101):        folders.append(&#39;{}{:0&gt;3}&#39;.format(&#39;beijing&#39;, i))    pool = multiprocessing.Pool()    for i in xrange(len(folders)):        folder = folders[i]        print &quot;{} - {} - START...&quot;.format(folder, time.asctime(time.localtime()))        pool.apply_async(list_blobs, args=(folder,))    pool.close()    pool.join()    print time.asctime(time.localtime()) + &quot; Done.&quot;</code></pre>]]></content>
      
      <categories>
          
          <category> Azure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Azure </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac | Mac各种折腾v1.0</title>
      <link href="/2015/03/31/05.Mac%20%7C%20Mac%E5%90%84%E7%A7%8D%E6%8A%98%E8%85%BEv1-0/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：记录了使用Mac三年以来，各种搜索得到&amp;搜索不到的问题&amp;方法。</p></blockquote><a id="more"></a><h2 id="硬件-amp-软件环境"><a href="#硬件-amp-软件环境" class="headerlink" title="硬件 &amp; 软件环境"></a>硬件 &amp; 软件环境</h2><ul><li>Macbook pro 13-inch, Mid 2012</li><li>OS X 10.10.2</li></ul><h2 id="合并磁盘失败"><a href="#合并磁盘失败" class="headerlink" title="合并磁盘失败"></a>合并磁盘失败</h2><p>合并磁盘失败通常发生在抹去BootCamp上的windows时。不知道大家有没有尝试过抹去windows，虽然BootCamp提供了抹去windows的功能，但是本人抹过几次，从来没有成功把回收的windows硬盘空间合并进Mac硬盘空间。即使windows所占硬盘空间不大，但逼死强迫症OTZ。</p><p>解决办法：重启电脑，按command+s进入命令行启动页面，输入<code>fsck -f</code>，再输入<code>reboot</code>，系统会重启。启动完毕后再利用BootCamp或Disk Utility合并即可。</p><h2 id="关闭Dashboard"><a href="#关闭Dashboard" class="headerlink" title="关闭Dashboard"></a>关闭Dashboard</h2><p>Dashboard真的是挺鸡肋的功能，尤其在Yosemite的通知中心极大强化之后。Dashboard的Widgets也停止更新了。在Terminal中输入如下命令即可关闭Dashboard。</p><pre><code>&gt;&gt; defaults write com.apple.dashboard mcx-disabled -boolean YES&gt;&gt; killall Dock</code></pre><h2 id="制作OS-X系统安装盘"><a href="#制作OS-X系统安装盘" class="headerlink" title="制作OS X系统安装盘"></a>制作OS X系统安装盘</h2><ol><li>下载安装文件<code>Install OS X Yosemite.app</code>(位置自选，我放在桌面上)</li><li>将U盘(&gt;=8G)格式化为Mac OS扩展（日志式），选项中选择GUID分区表(名称自拟，我设为DISK)</li><li>输入如下命令：</li></ol><pre><code>&gt;&gt; sudo ~/Desktop/Install\ OS\ X\ Yosemite.app/Contents/Resources/createinstallmedia --volume /Volumes/DISK --applicationpath ~/Desktop/Install\ OS\ X\ Yosemite.app --nointeraction</code></pre><h2 id="自制Fusion-Drive"><a href="#自制Fusion-Drive" class="headerlink" title="自制Fusion Drive"></a>自制Fusion Drive</h2><p>光驱是MBP101上留之无用，弃之可惜的功能。将光驱功能最大化的办法，就是将光驱改成外接形式，在原来光驱位上加装固态硬盘。然后问题来了，系统怎么搞？常见的办法是将系统安装在固态硬盘上，而把机械硬盘用作数据盘。但是本人系统盘原本就近300G，远超固态硬盘容量。只想用Time Machine拷贝，懒得删文件，所以捣鼓了Fusion Drive，完美解决。过程如下：</p><ol><li>用Time Machine做好系统备份</li><li>用U盘做好系统安装盘</li><li>插上U盘安装盘，按住option开机，进入U盘</li><li>选择磁盘工具，将SSD和HDD都抹为MAC OS扩展（日志式）</li><li>打开终端，输入：</li></ol><pre><code>&gt;&gt; diskutil list &gt;&gt; diskutil cs create &quot;Macintosh FD&quot; disk0 disk1(出现Finished CoreStorage operation表示成功)&gt;&gt; diskutil cs createvolume [LVG的UUID，在上一步的输出中可以看到] jhfs+(j指journal日志式 HFS+是苹果的文件系统，就和前文格式化的Mac OS 扩展日志式一样) &quot;Macintosh FD&quot;(这个名称可以自己起，和前面一样，中间有空格的话两边加双引号) 600g(分区大小)</code></pre><p>制作完成。然后退出终端，从Time Machine恢复或者重新安装即可。</p><p>参考资料：<a href="http://tieba.baidu.com/p/1992600787?pn=1&amp;see_lz=1" target="_blank" rel="noopener"></a></p><h2 id="MAC-VPN"><a href="#MAC-VPN" class="headerlink" title="MAC VPN"></a>MAC VPN</h2><p>Apple死忠，一直坚持用原生App，包括Safari。但是因为插件支持不如Chrome，在使用VPN时没有办法利用插件实现智能代理。而打开全局代理，很多App就没法使用。最好是能在全局使用VPN时也能实现代理。解决办法如下：</p><pre><code>VPN-&gt;Advanced-&gt;Proxies-&gt;Automatic Proxy Configuration, Proxy Configuration File URL: http://pac.uku.im/pac.pac</code></pre><p>设置完毕后打开VPN，输入URL<code>http://uku.im/check</code>，如果显示true说明设置成功。</p><p>参考资料：<a href="https://github.com/zhuzhuor/Unblock-Youku/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener"></a></p><h2 id="MAC上将Safari书签同步到Chrome"><a href="#MAC上将Safari书签同步到Chrome" class="headerlink" title="MAC上将Safari书签同步到Chrome"></a>MAC上将Safari书签同步到Chrome</h2><p>折腾这件事的原因同上。调试前端不得不用Chrome，于是有了这样的需求。自己折腾的办法如下：</p><ol><li>清空Chrome书签</li><li>书签-&gt;导入书签和设置</li></ol><p>在Windows上直接在Chrome上安装iCloud Bookmarks插件即可。</p>]]></content>
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>密码学 | Enigma破解分析</title>
      <link href="/2015/03/09/04.%E5%AF%86%E7%A0%81%E5%AD%A6%20%7C%20Enigma%E7%A0%B4%E8%A7%A3%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：详细分析了对雷杰夫斯基和图灵破解Enigma的工作。</p></blockquote><a id="more"></a><p>Enigma的破译可以分成两个阶段。第一个阶段是由波兰人雷杰夫斯基为首完成的，利用的是临时密钥的重复发送。在德国人去除了这一漏洞之后，第二个阶段是由英国人图灵完成的。下面分别介绍。</p><p><img src="/BlogImages/Enigma破解分析/Enigma.png" alt=""></p><h2 id="雷杰夫斯基的工作"><a href="#雷杰夫斯基的工作" class="headerlink" title="雷杰夫斯基的工作"></a>雷杰夫斯基的工作</h2><p>雷杰夫斯基所利用的是德军在使用Enigma机器时重复发送密钥所带来的一个漏洞。德军当时使用Enigma机器的方式为，首先有一个记录了一个月中每天所使用的密钥的密码本，然后在当天的每次加密前，选取三个字母表示转子的初始方向，例如ZRW，作为本次加密的临时密钥，用密码本上当天的密钥加密两遍临时密钥，例如ZRWZRW（为了防止偶然的发送或接受错误），之后在用临时密钥加密正文。所以每天德军所发送的密文的前六个字母都是用当天的密钥所加密的重复两遍的临时密钥。利用这一点，雷杰夫斯基的方法得以奏效。</p><p>假设临时密钥为ZRW，ZRWZRW用当日密钥加密后为ASDFGH。考虑前后两个Z，它们分别被加密为了A和F，这是由于快转子在两次加密Z之间转动了三次。这样A和F之间作为同一个字母第一次和第四次被加密的结果，就存在对应关系。通过当天收集大量的密文，我们可以找出密文第一个和第四个字母间存在的所有的对应关系。例如：</p><pre><code>第一个字母:ABCDEFGHIJKLMNOPQRSTUVWXYZ第四个字母:FQHPLWOGBMVRXUYCZITNJEASDK</code></pre><p>在这个表中，存在若干字母循环圈，例如A-&gt;F-&gt;W-&gt;A。写出所有的字母循环圈：</p><pre><code>A→F→W→A                3个字母的循环圈B→Q→Z→K→V→E→L→R→I→B    9个字母的循环圈C→H→G→O→Y→D→P→C        7个字母的循环圈J→M→X→S→T→N→U→J        7个字母的循环圈</code></pre><p>这些循环圈是由当日密钥决定的，但是循环圈的个数、每个循环圈的长度只由转子的情况决定，与连接板的情况无关。下面我们通过论证连接线对对应关系的影响来不严格地证明无关性。</p><p>首先我们不妨假设R和W是相连的。现在考虑去除连接线会造成什么影响。把连接线的影响可以分为两部分：输入和输出。从输入的角度来看，如果连接线对输入的影响不存在了（即输入R的时候不会经过连接线到W，但是输出R的时候会经过连接线到W），可以发现对应关系表是不变的（改变的是每列对应的明文字母）。从输出的角度来看，原本输出R时实际输出的是W，原本输出W时实际输出的是R。需要把第一行中R和W在第二行中对应的字母对调，把第二行中R和W在第一行中对应的字母对调。这对循环圈造成的影响是，交换了R和W在循环圈中的位置。循环圈的个数、每个循环圈的长度不变。同样，我们可以证明加上连接线的效果相同。</p><p>所以，循环圈的个数、每个循环圈的长度可以作为转子状态的一个特征。同样，第2、5个字母和第3、6个字母之间的对应关系同样可以找出来，再确定循环圈的个数、每个循环圈的长度，也可以作为转子状态的特征。如果能够构造一个完备的对照表，我们可以通过这些特征，确定转子的状态。由于这里的分析与连接板状态无关，而转子的状态一共有3!*26^3=105456种，可以采用穷举的关系建立上述的对照表。对照表中的一条记录可以是这样的：</p><pre><code>第一和第四字母对应表中有4个循环圈，长度分别为3,9,7,7;第二和第五字母对应表中有4个循环圈，长度分别为2,3,9,12;第三和第六字母对应表中有5个循环圈，长度分别为5,5,5,3,8;</code></pre><p>在找出当日密钥中转子的状态之后，还需要确定连接板的情况才能破解密钥。这一部分没有查找相关的资料。在我看来，一种可行的办法是通过增减连接线来交换字母在循环圈中的位置，使得循环圈与实际的循环圈一致。</p><p>雷杰夫斯基的方法的缺陷在于，如果德军不再重复发送密钥，或者增加转子的个数，他的方法便不再可行。</p><h2 id="图灵的工作"><a href="#图灵的工作" class="headerlink" title="图灵的工作"></a>图灵的工作</h2><p>图灵利用的如下几个条件来建立一些明文与密文的对应：</p><ol><li>德军在每天的固定时间会发送固定格式的密文，例如在每天早上六点会发送天气预报。由于固定格式，往往就有确定的单词出现，例如天气预报中会出现天气（德文wetter），这样就可以猜测这样的密文中一定存在特定的明文单词。</li><li>由于Enigma设计中反射器的存在，Enigma加密时一定不会把一个字母映射为字母本身。</li></ol><p>根据第一点，可以确定明文单词在密文中的大致位置，然后结合第二点，根据有没有字母映射到本身这一条件差不多可以确定明文的准确位置。下面的工作就是根据一些明文和对应的密文进行破解。</p><p>首先需要在已知明文中找到最小的一个字母循环圈。假设wetter对应的密文为ETJWPX，则这里存在W-&gt;E-&gt;T-&gt;W的循环圈。设在加密wetter前Enigma的状态为S，加密n个字母后为S+n。如果我们取三台机器，状态分别为S、S+1、S+3，将他们的输出与后者的输入依次相连，则S的W-&gt;S+1的E-&gt;S+3的T-&gt;S的W，构成了一条回路。</p><p>进一步，如果不考虑连接板，我们取三台机器，第一台状态记为S，调节第二台为S+1，调节第三台为S+3，按1-2-3-1的顺序输出与输入相连。如果其中不存在回路，则说明转子的状态与密钥不同。如果其中存在回路，则说明转子的状态很可能为密钥中转子的状态，同时这条回路很可能是字母循环圈。然后只需要用连接线把对应的字母对相连即可。例如，找到的字母循环圈为R-&gt;E-&gt;L-&gt;R，则用连接线连接R和W，L和T。至此密钥破解完成。</p><p>以上。</p><hr><p>参考资料：《Enigma的兴亡》</p>]]></content>
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> Enigma </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac | Mac小工具集锦v1.0</title>
      <link href="/2015/02/18/03.Mac%20%7C%20Mac%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E9%94%A6v1-0/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：有刚入手Mac的朋友问有哪些工具推荐，于是整理一篇实用小工具的简介，与大家分享一下。</p></blockquote><a id="more"></a><p>原本想写个完整的软件介绍，写着写着发现大部分都是废话。简洁有用至上，我就改写一些对提升效率有帮助的小工具吧。</p><ol><li>CheatSheet: 长按command键可以弹出当前所有可用的快捷键。熟记快捷键之后能够显著提高效率。</li><li>Alfred: 键盘流软件。熟练掌握可以极大减少鼠标和触控板的使用。目前Spotlight也在往类似的方向转变。</li><li>Moom: 用于窗口控制，弥补了OS X在分屏上相对于Windows的劣势，提供了丰富的分屏方案。拯救像在下一样，既不喜欢几个应用窗口重叠，也不喜欢自己折腾布局，而且还总是对不齐！！！强迫症福音。</li><li>XMind: 思维导图软件。图形化之后，很多混乱的事情就有救了，一图胜千言。</li><li>AntiRSI: 定时提醒你离开电脑休息一会儿，拯救颈椎病。</li><li>Scroll Reverser: 颠倒触控板和鼠标滚轮滑动的方向，可以与Windows保持一致。不过既然Mac如此的设计，个人不推荐修改。</li><li>smcFanControl: 监视CPU温度和风扇转速，也可以手动调节风扇转速。</li><li>CloudApp: 图床软件，可以上传小文件并生成引用或者下载链接。</li><li>AppCleaner: 用于卸载软件，卸载软件不只是在应用程序文件夹里删掉就好了喔。</li><li>AirServer: 利用AirPlay可以在电脑上提供iPhone和iPad的镜像。</li><li>VLC: 开源的视频播放软件，支持格式很丰富。</li><li>GoAgentX, ShadowsocksX: 翻墙用。嘘。</li><li>Jitouch: 自定义触控板手势，如果不习惯键盘流，这种方式也很方便。</li><li>Mou: Markdown编辑器。强烈建议所有人学习Markdown，文档的内容既条理清晰，生成的PDF或者网页也很漂亮，省去排版的烦恼。</li><li>Deckset: 用Markdown做演示文稿。由于Markdown语法很简单，加上模板很棒，快速制作简单的演示文稿会比Pages和PPT更方便。</li></ol><p>以后再补充吧~</p>]]></content>
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Haskell | Monad初探</title>
      <link href="/2014/12/22/02.Haskell%20%7C%20Monad%E5%88%9D%E6%8E%A2/"/>
      <content type="html"><![CDATA[<blockquote><p><strong>摘要</strong>：学习Haskell的过程中一时无法理解Monad的概念，于是探索了一番，将心得记录如下。</p></blockquote><a id="more"></a><p>我试图从如下的定义里看穿Monad的真相。</p><blockquote><p>A monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p><p>Monad是自函子范畴上的幺半群。</p></blockquote><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>首先，对于如下相关的概念我尝试给出我自己的定义。</p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>Haskell的类型系统相当复杂。不同于OO只是一层抽象，Haskell抽象多得可怕。目前我给出的分层如下：</p><p><img src="/BlogImages/Monad初探/Monad_1.png" alt=""></p><p>从下往上是按照从具体到抽象。首先是具体的值<code>Value</code>，其次是将<code>Value</code>抽象为特定类型<code>Proper Type</code>，然后<code>Proper Type</code>又被抽象为高阶(包含一阶)类型<code>Higher Order Type</code>，最后是最抽象的<code>kind</code>。而<code>Monad</code>是什么呢？它是<code>kind</code>为<code>* -&gt; *</code>的一种类型类。</p><h3 id="函数与函子"><a href="#函数与函子" class="headerlink" title="函数与函子"></a>函数与函子</h3><blockquote><p>此处的函数狭义地仅指Haskell里的方法，即输入参数和输出参数均为<code>Proper Type</code>的一一映射</p></blockquote><p>函数<code>Function</code>是指输入参数和输出参数均为<code>Proper Type</code>的一一映射，而函子<code>Functor</code>是指输入参数和输出参数均为<code>Higher Order Type</code>的一一映射。其中<code>Functor</code>的定义不够准确，在范畴部分会继续补充。</p><h3 id="自函数与自函子"><a href="#自函数与自函子" class="headerlink" title="自函数与自函子"></a>自函数与自函子</h3><p>前面我们已经给出了<code>Function</code>的定义，用代码表示就是<code>Type A -&gt; Type B</code>。如果此处的<code>Type B</code>包含于<code>Type A</code>，那么我们就称此函数为自函数<code>Endofunction</code>。特别的，如果<code>Type B</code>等于<code>Type A</code>，则称其为<code>Identity Function</code>。</p><p>类比自函数，什么是自函子<code>Endofunctor</code>呢？对于<code>Higher Order Type A -&gt; Higher Order Type B</code>，如果<code>Higher Order Type B</code>包含于<code>Higher Order Type A</code>，则我们称此函子为自函子。同样的，如果<code>Higher Order Type B</code>等于<code>Higher Order Type A</code>，则称其为<code>Identity Functor</code>。</p><h3 id="范畴"><a href="#范畴" class="headerlink" title="范畴"></a>范畴</h3><p>我不打算从很严谨的定义阐明范畴<code>Category</code>的概念。通俗地讲，我理解的范畴就是对象+态射。那么在Haskell中什么是范畴呢？</p><p>最重要的我认为是一个<code>Higher Order Type</code>对应于一个<code>Category</code>，其中被该<code>Higher Order Type</code>所抽象的<code>Proper Type</code>就是该<code>Category</code>的对象，而以这些<code>Proper Type</code>为入参和出参的<code>Function</code>就是该<code>Category</code>的态射。</p><h3 id="函子深入"><a href="#函子深入" class="headerlink" title="函子深入"></a>函子深入</h3><p>然后<code>Functor</code>的概念可以进一步深入。刚刚说道，函子<code>Functor</code>是指输入参数和输出参数均为<code>Higher Order Type</code>的一一映射，更准确的，<code>Functor</code>是<code>Higher Order Type</code>所对应的范畴之间的映射，它包括对对象的映射和对态射的映射。举个例子，考虑<code>a -&gt; [a]</code>作为<code>Functor</code>，它是<code>Identity</code>对应的范畴和<code>List</code>对应的范畴之间的映射。第一它可以作为对象之间的映射，例如它是<code>Int -&gt; [Int]</code>之间的映射，第二，作为对态射的映射，由于<code>[]</code>有<code>map</code>方法，所以它还是<code>(Int -&gt; Int) -&gt; [Int] -&gt; [Int]</code>之间的映射。</p><blockquote><p>在Haskell中有类型类<code>Functor</code>，它接受高阶类型作为实例，高阶类型本身就是类型构造器，它就是对象之间的映射。<code>Functor</code>实例必须实现<code>fmap</code>方法，它又是态射之间的映射。</p></blockquote><h3 id="半群与幺半群"><a href="#半群与幺半群" class="headerlink" title="半群与幺半群"></a>半群与幺半群</h3><p>我们知道群是指满足的封闭性、结合律、有幺元、逆元的非空集合+二元运算<code>(G, *)</code>。当<code>(G, *)</code>满足封闭性、结合律时它是一个半群，进一步，如果还有幺元，则它是一个幺半群。</p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>上面说了一大堆，如果不具体到Monad的定义上被觉得都是扯淡。回顾开头部分引用的定义。</p><blockquote><p>Monad是自函子范畴上的幺半群。</p></blockquote><h3 id="自函子范畴"><a href="#自函子范畴" class="headerlink" title="自函子范畴"></a>自函子范畴</h3><p>首先，考虑什么是自函子范畴？上面说过，粗浅地认为范畴=对象+态射。既然是自函子范畴，对象自然是自函子。而实际上如果把Haskell所有类型和方法统一作为一个范畴，则Haskell上所有的函子都是自函子（<strong>这一点还有些模糊</strong>）。用Haskell代码表示这里的自函子就是<code>a -&gt; m b</code>，其中<code>a, b</code>是类型参数，<code>m</code>是高阶类型。</p><p>那么接下来的问题就是自函子范畴上的态射是什么。根据函子范畴的定义，这里的态射叫做自然变换。维基上的解释还比较清晰，用Haskell代码表示从函子<code>a - &gt; m b</code>到<code>a -&gt; m c</code>的自然变换就是<code>m b -&gt; m c</code>。所有这些自然变换就构成了自函子范畴上的态射。</p><h3 id="自函子范畴上的幺半群"><a href="#自函子范畴上的幺半群" class="headerlink" title="自函子范畴上的幺半群"></a>自函子范畴上的幺半群</h3><p>然后作为这个自函子范畴上的幺半群<code>(G, *)</code>，非空集合G自然就是自函子构成的集合，而二元运算<code>*</code>是什么呢？幺元是什么呢？</p><p>回忆Haskell中对Monad实例的要求是实现<code>return</code>函数和<code>&gt;&gt;=</code>函数，它们的定义如下：</p><pre><code class="haskell">class Monad (m :: * -&gt; *) where    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b    return :: a -&gt; m a</code></pre><p>根据函数声明可以看出，<code>return</code>本身就是一个特殊的自函子，而<code>&gt;&gt;=</code>酷似二元运算。我们自然地猜测<code>&gt;&gt;=</code>就是这个幺半群的二元运算，<code>reutrn</code>就是幺元。但是<code>&gt;&gt;=</code>并不完全符合二元运算的定义，所以我们定义新的函数：</p><pre><code class="haskell">    &gt;=&gt; :: (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</code></pre><p>显然，<code>&gt;=&gt;</code>符合这个幺半群里对二元运算的定义。<code>&gt;&gt;=</code>与<code>&gt;=&gt;</code>的关系为对于任意两个函子<code>f, g</code>，有<code>(f x) &gt;&gt;= g</code>等价于<code>(f &gt;=&gt; g) x</code>。</p><h4 id="封闭性"><a href="#封闭性" class="headerlink" title="封闭性"></a>封闭性</h4><p><del>对于任意两个自函子<code>f: a -&gt; m b</code>以及<code>g: b -&gt; m c</code>，那么<code>&gt;&gt;= g</code>就是一个<code>m b -&gt; m c</code>的自然变换，将<code>f</code>映射为<code>h: a -&gt; m c</code>，而显然<code>h</code>也是一个自函子，所以满足封闭性。用代码表示就是<code>(&gt;&gt;= g) . f = h</code>。</del></p><p>对于任意两个自函子<code>f: a -&gt; m b</code>以及<code>g: b -&gt; m c</code>，那么<code>f &gt;=&gt; g</code>得到<code>h: a -&gt; m c</code>的自然变换，而显然<code>h</code>也是一个自函子，所以满足封闭性。</p><h4 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h4><p><del>对于任意三个自函子<code>f: a -&gt; m b</code>, <code>g: b -&gt; m c</code>, <code>h: c -&gt; m d</code>，先考虑<code>(f * g) * h</code>的顺序，计算<code>(&gt;&gt;= h) . ((&gt;&gt;= g) . f) = a - &gt; m d</code>。再考虑<code>f * (g * h)</code>的顺序，计算<code>(&gt;&gt;= (&gt;&gt;= h) . g) . f = a - &gt; m d</code>。所以结合律成立。</del></p><p>对于任意三个自函子<code>f: a -&gt; m b</code>, <code>g: b -&gt; m c</code>, <code>h: c -&gt; m d</code>，先考虑<code>(f * g) * h</code>的顺序，计算<code>(f &gt;=&gt; g) &gt;=&gt; h = a - &gt; m d</code>。再考虑<code>f * (g * h)</code>的顺序，计算<code>f &gt;=&gt; (g &gt;=&gt; h) = a - &gt; m d</code>。所以结合律成立。</p><h4 id="幺元"><a href="#幺元" class="headerlink" title="幺元"></a>幺元</h4><p><del>首先验证左结合律。取任意自函子<code>f: a -&gt; m b</code>，考虑<code>return * f</code>，计算<code>(&gt;&gt; f) . return = a -&gt; m b = f</code>。左结合律成立。再验证右结合律，考虑<code>f * return</code>，计算<code>(&gt;&gt;= return) . f = a -&gt; m b = f</code>，右结合律成立。</del></p><p>首先验证左结合律。取任意自函子<code>f: a -&gt; m b</code>，考虑<code>return * f</code>，计算<code>return &gt;=&gt; f = a -&gt; m b = f</code>。左结合律成立。再验证右结合律，考虑<code>f * return</code>，计算<code>f &gt;=&gt; return = a -&gt; m b = f</code>，右结合律成立。</p><p>综上，我们验证了实现了<code>return</code>和<code>&gt;=&gt;</code>(也就是实现了<code>return</code>和<code>&gt;&gt;=</code>)的Monad实例确实是自函子范畴上的幺半群。这里我们暂时不再证明满足自函子范畴上的幺半群一定是Monad的结论。</p><h2 id="Monad有什么用"><a href="#Monad有什么用" class="headerlink" title="Monad有什么用"></a>Monad有什么用</h2><p>费尽千辛万苦终于理解了开头一句话的意思，但现在面临的问题是引入Monad究竟给Haskell带来了什么好处呢？无非是解决非纯函数带来的副作用的问题。</p><p>那么Monad怎么解决副作用问题呢？</p><p>在维基百科的Haskell词条中有如下描述：</p><blockquote><p>它是一门纯函数编程语言，这意味着大体上，Haskell中的函数没有副作用。Haskell用特定的类型来表达副作用，该类型与函数类型相互独立。纯函数可以操作并返回可执行的副作用的类型，但不能够执行它们，只有用于表达副作用的类型才能执行这些副作用，Haskell以此表达其它语言中的非纯函数。</p></blockquote><p>按照我的理解，Haskell对于这些可能有副作用的类型构造了相应的高级类型<code>Higher Order Type</code>，也就是形成了对立于没有副作用的范畴的新范畴。而在这两个范畴之间，通过Monad联系起来。若记无副作用范畴为C1，有副作用范畴为C2。这种联系只有从C1到C2的单向方法以及C2的内部方法，不存在从C2到C1的方法。通过这样的设计来隔离这两个范畴。</p><p>还是最初以导致Monad引入的IO类型作为例子说明。</p><p>这里的自函子为<code>IO</code>函子，它对Monad类型类的实现如下：</p><pre><code class="haskell">instance Monad IO where    return x = IO x    IO x &gt;&gt;= f = f x</code></pre><p>IO是显然的具有副作用的操作。IO类型将这种操作封装为一种类型，<code>return</code>操作提供了从C1到C2的方法，<code>&gt;&gt;=</code>操作提供了C2的内部方法。更准确的说法是道可叨中的说法：<code>return</code>是一种最自然的类型提升，也就是单位函子，<code>&gt;&gt;=</code>是一种首先的类型下降，但是确保了结果还是在IO类型的范畴当中。</p><p>通过Monad的机制，确保了有副作用的范畴中的执行始终停留在有副作用的范畴中，不会影响原来的类型。</p><p>最后我想补充一点，Monad是如何解决执行顺序对于有副作用函数的影响。我的理解是<code>&gt;&gt;=</code>实际上类似于shell中的<code>|</code>，它构造了一种管道，使得函数的执行是有顺序的。但是这与幺半群的结合律是否矛盾呢？并不矛盾。因为例如对于<code>m &gt;&gt;= f &gt;&gt;= g ...</code>中除了第一个参数，后续的部分只是明确了执行的过程，并没有实际的输入执行，必须等到<code>m</code>进入管道后才能真正开始计算结果。所以与结合律并不矛盾。</p><p>引用道可叨的一张图，希望能帮助理解。</p><p><img src="/BlogImages/Monad初探/Monad_2.png" alt=""></p><!--> 原本我觉得上面这一段中提出执行顺序问题，是可以在前面关于隔离两个范畴的讨论中解决掉的，但是并没能太想清楚--><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>有道寒假实践题目是调查自己的家族图谱。如果我们构想了一个数据结构存储了所有收集到的关于一个族谱的信息。从其中某一个人出发，要获得与他相关的任意一个人，可以经过一步或者多步如下的关系获得：父亲(father)，母亲(mother)，丈夫或妻子(husbandOrWife)，长子或长女(eldestChild)，最大的弟弟或妹妹(nextChild)</p><p>于是我构造了如下的例子：</p><pre><code class="haskell">data Person = Person String              deriving Showfather :: Person -&gt; Maybe Personmother :: Person -&gt; Maybe PersonhusbandOrWife :: Person -&gt; Maybe PersoneldestChild :: Person -&gt; Maybe PersonnextChild :: Person -&gt; Maybe Person</code></pre><p>这里我们用了Monad类型的<code>Maybe</code>。它给我们带来了什么好处呢？由于不是每一个人都拥有上述五种关系的人，或者由于族谱的缺失，数据不一定完整。所以有可能经过上述某一步操作，没有期望的结果。如果我们采用对函数结果进行判断，则代码会演变成类似<code>If...else...</code>结构冗长的嵌套。<code>Maybe</code>由于实现了Monad类型，通过<code>&gt;&gt;=</code>我们可以正常地寻找某人，中间过程不用加以判断，如果某一步出现找不到，则结果会变为<code>Nothing</code>(不是说他不是东西。。。)。简直太有爱了！</p><p>从范畴角度来看，由于<code>Maybe</code>类型存在例外的<code>Nothing</code>的情况，所以Monad使得涉及<code>Maybe</code>的操作被限制在<code>Maybe</code>对应的范畴内，从而使程序设计变得容易。</p><!--写了这么多，我只想说。。。心好累。。。--><p><br><br><br><br><br><br><br></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>我所理解的monad系列0-5 <a href="http://hongjiang.info/understand-monad-0/" target="_blank" rel="noopener">链接</a></li><li>道可叨 <a href="http://zhuoqiang.me/what-is-monad.html" target="_blank" rel="noopener">链接</a></li><li>自然变换 - 维基百科 <a href="http://zh.wikipedia.org/wiki/自然變換" target="_blank" rel="noopener">链接</a></li><li>知乎问题 - 如何解释Haskell中的单子？parker liu的回答 <a href="http://www.zhihu.com/question/22291305" target="_blank" rel="noopener">链接</a></li><li>Haskell/Understanding Monad <a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws" target="_blank" rel="noopener">链接</a></li></ol>]]></content>
      
      <categories>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
            <tag> Monad </tag>
            
            <tag> 范畴论 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
